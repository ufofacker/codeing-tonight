let utils = require ('../../utils');
const bindTextToElement = utils.bindTextToElement;
//${bindTextToElement ('')}
module.exports = {
  list: [
    {
      label: '1.变量提升和函数提升',
      content: `${bindTextToElement ('变量提升和函数提升')}，指的是JS代码在编译的过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码行开头的“行为”。而对于变量声明而言，JS引擎会给其一个默认值undefined。JS代码在执行过程中一般会经过两个阶段，如下：</br>` +
        `${bindTextToElement ('编译阶段')}：一段JS代码经过编译后，会生成“执行上下文”和“可执行代码”，前者是JS代码的运行环境，它由两部分组成，分别是：①变量环境：该环境中保存了变量提升后的内容，②词法环境：用来跟踪标识符和特定变量之间的映射关系，及管理作用域。而后者是JS代码经过JS引擎编译后生成的可执行代码，可执行代码中除了变量声明被存储在栈里，剩余的代码均会被编译为字节码并被存储起来。</br>` +
        `${bindTextToElement ('执行阶段')}：JS引擎开始按顺序一行一行的执行由编译阶段生成的“可执行代码”，当碰到变量时，就在变量环境中查询变量对应的值。当碰到函数时，就在变量环境中查找该函数引用对应的函数并执行。</br>` +
        `在实际开发过程中，也会碰到同名函数，同名的方法和变量这种情况，JS引擎在编译的时候碰到同名的变量声明和函数，那么会忽略掉变量声明，而保留函数声明。如果是同名函数，那么最后声明的函数会覆盖前边声明的函数</br>`,
    },
    {
      label: '2.调用栈',
      content: `JS代码中调用函数，JS引擎会为其创建执行上下文，并把该执行上下文压入到调用栈中，然后JS引擎开始执行函数代码</br>` +
        `如果在一个函数A中调用了另外一个函数B，那么JS引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。</br>` +
        `当前函数执行完成后，JS引擎会将该函数的执行上下文从调用栈中弹出。`,
    },
    {
      label: '3.作用域',
      content: `作用域就是指变量和函数的可访问范围。ES6之前只有全局作用域和函数作用域，ES6引入了块级作用域的概念。</br>` +
        `${bindTextToElement ('①全局作用域')}：JS文件根部产生的的作用域被称为全局作用域，全局作用域中的变量和方法在JS文件内的任何代码区域中都可被访问。其生命周期与页面的生命周期相似。</br>` +
        `${bindTextToElement ('②函数作用域')}：JS函数内定义的变量，函数的作用范围被称为函数作用域。</br>` +
        `${bindTextToElement ('③块级作用域')}：一对大括号包裹一段JS代码，这种方式产生的作用范围被称为块级作用域。</br>`,
    },
    {
      label: '4.作用域链',
      content: `${bindTextToElement ('作用域链')}：通过作用域查找变量的链条称为作用域链。实际上，在每个执行上下文环境中都会存在一个外部引用outer，而outer正是作用域形成作用域链的关键，在学习作用域链的过程中，还会涉及到词法作用域及闭包效应。下面分开讲解</br>` +
        `${bindTextToElement ('词法作用域')}：由函数声明的位置层级决定的作用域被称为词法作用域，词法作用域是静态作用域，由它产生的作用域链称为词法作用域链，它可以用来确定代码查询标识符的范围和路线。</br>` +
        `${bindTextToElement ('闭包')}：在JS中，根据词法作用域规则，内部函数总是可以访问其外部函数中声明的变量，当通过一个外部函数返回一内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包（closure）。假如外部函数的名称为test，那么这些变量的集合就称为test函数的闭包</br>` +
        `由于闭包会导致闭包内的变量或者方法不能被JS的垃圾回收机制回收，从而可能有内存泄漏的风险。因此在使用闭包的时候要结合场景适当使用。如果想要闭包一直可以被访问，那么就把他挂载到全局变量上，如果想要在某个时期内可以被访问，那么就把它挂载到局部变量上。</br>`,
    },
    {
      label: '5.this机制',
      content: `this机制是为了实现在对象内部的方法中访问对象内部的属性。使用this，一般需要注意以下几点：</br>` +
        `在全局执行上下文中调用一个函数，函数内部的this指向的是全局变量window${bindTextToElement ('(非严格模式，如果是严格模式那么是undefined)')},通过一个对象调用其内部的方法，该方法的执行上下文中的this指向对象本身，需要注意的是非嵌套函数中的this不会继承外层的this值。</br>` +
        `总结下，可以这么理解this的指向，this总是指向调用方法的那个对象，也就是谁调用了方法，this就指向谁。</br>`,
    },
  ],
};
